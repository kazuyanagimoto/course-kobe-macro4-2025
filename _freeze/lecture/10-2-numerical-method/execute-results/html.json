{
  "hash": "197f2d6010c89a83ebddaf823e3a9e2d",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: 数値計算の補足\ndate: last-modified\nengine: julia\nformat:\n  html:\n    code-tools: true\n---\n\n\n\n\n## 計算量\n\nアルゴリズムの効率性を評価する尺度として、計算時間とメモリ使用量があります. ここでいう計算時間とは, アルゴリズムが終了するまでにかかるステップ数 (**時間計算量**, time complexity) のことをいい, 実際のPC上での実行時間とは異なります. より高いスペックのPCを使えば, 同じアルゴリズムでも実行時間は短くなる一方で, ステップ数の次元が異なるアルゴリズムはマシンの性能に関わらず効率的と言えます.また, メモリ使用量とはアルゴリズムが終了するまでに必要なメモリの量 (**領域計算量**) のことをいいます.\n\n### 時間計算量\n\n時間計算量は, 入力の大きさ $n$ に対するステップ数 $T(n)$ の関数として表されます. 例えば, 配列の要素数が $n$ のときに, すべての要素を1回ずつ見るアルゴリズムは, $T(n) = n$ となります. また, 2重ループで配列のすべての組み合わせを調べるアルゴリズムは, $T(n) = n^2$ となります. このように, アルゴリズムの時間計算量は, 入力の大きさに対するステップ数の増加率によって特徴づけられます.\n\n時間計算量を評価する際, 重要なのは支配的な項の次元数になります. 例えば, $T(n) = 3n^2 + 2n + 1$ の場合, $n$ が大きくなると $3n^2$ の項が支配的になるため, $n^2$ に着目すれば十分です. この考え方に従ったとき, 計算量を $O(n^2)$ と表記します. より厳密に表現すると以下のようになります.\n\n::: {.callout-note}\n\n## $O$-記法\n\n$f(n)$ が $O(g(n))$ とは, 任意の $n \\ge 0$ に対して, ある定数 $C > 0$ が存在して, 以下の不等式が成り立つことをいう.\n\n$$\n|f(n)| \\le C |g(n)|.\n$$\n\n:::\n\n",
    "supporting": [
      "10-2-numerical-method_files"
    ],
    "filters": [],
    "includes": {}
  }
}